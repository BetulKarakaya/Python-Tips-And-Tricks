class ClosureDemo:
    """Create and hold lists of callables that illustrate wrong vs correct closures."""

    def __init__(self, count=3):
        self.count = count
        self.wrong_funcs = []
        self.correct_funcs = []
        self._prepare_wrong()
        self._prepare_correct()

  
    # Wrong approach: lambdas capture the same final value of 'i'

    def _prepare_wrong(self):
        self.wrong_funcs.clear()
        for i in range(self.count):
            # late binding: each lambda refers to the variable 'i' which will be its final value when called
            self.wrong_funcs.append(lambda: i)

    # Correct approach: bind current 'i' using default parameter
    def _prepare_correct(self):
        self.correct_funcs.clear()
        for i in range(self.count):
            # early binding: default parameter captures the current value immediately
            self.correct_funcs.append(lambda i=i: i)

    def call_wrong(self):
        """Call each function generated by the wrong approach and return results as a list."""
        return [f() for f in self.wrong_funcs]

    def call_correct(self):
        """Call each function generated by the correct approach and return results as a list."""
        return [f() for f in self.correct_funcs]

    def describe(self):
        """Return a short textual description of the instance state."""
        return f"ClosureDemo(count={self.count})"


def main():
    demo = ClosureDemo(count=4)  # change count to see different sizes

    print("Demo object:", demo.describe())

    print("\n--- WRONG (class-based) ---")
    # Expectation might be [0, 1, 2, 3], but due to late binding we get the final value repeated
    print("calls:", demo.call_wrong())    # e.g. [3, 3, 3, 3]

    print("\n--- CORRECT (class-based) ---")
    print("calls:", demo.call_correct())  # [0, 1, 2, 3]

    # Extra: show that regenerating functions changes behavior for wrong approach
    print("\n--- MODIFYING count & regenerating wrong funcs ---")
    demo.count = 2
    demo._prepare_wrong()   # re-create wrong_funcs with new count
    print("calls after re-prepare (wrong):", demo.call_wrong())  # [1, 1] -> final value of new loop

    print("\nSUMMARY:")
    print("- wrong approach: all functions capture the same loop variable; they reflect the variable's final value when called.")
    print("- correct approach: default parameter binds the current value immediately, avoiding late binding.")

if __name__ == "__main__":
    main()
